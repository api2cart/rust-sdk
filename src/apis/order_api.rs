/*
 * API2Cart OpenAPI
 *
 * API2Cart
 *
 * The version of the OpenAPI document: 1.1
 * Contact: contact@api2cart.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`order_abandoned_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderAbandonedListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_financial_status_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderFinancialStatusListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_find`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderFindError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_fulfillment_status_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderFulfillmentStatusListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_preestimate_shipping_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderPreestimateShippingListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_refund_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderRefundAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_return_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderReturnAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_return_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderReturnDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_return_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderReturnUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_shipment_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderShipmentAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_shipment_add_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderShipmentAddBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_shipment_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderShipmentDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_shipment_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderShipmentInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_shipment_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderShipmentListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_shipment_tracking_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderShipmentTrackingAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_shipment_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderShipmentUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_status_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderStatusListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_transaction_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderTransactionListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`order_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrderUpdateError {
    UnknownValue(serde_json::Value),
}


/// Get list of orders that were left by customers before completing the order.
pub async fn order_abandoned_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, customer_id: Option<&str>, customer_email: Option<&str>, store_id: Option<&str>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, skip_empty_email: Option<bool>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseOrderAbandonedList, Error<OrderAbandonedListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_customer_id = customer_id;
    let p_customer_email = customer_email;
    let p_store_id = store_id;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_skip_empty_email = skip_empty_email;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/order.abandoned.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_customer_id {
        req_builder = req_builder.query(&[("customer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_customer_email {
        req_builder = req_builder.query(&[("customer_email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_empty_email {
        req_builder = req_builder.query(&[("skip_empty_email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderAbandonedListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a new order to the cart.
pub async fn order_add(configuration: &configuration::Configuration, order_add: models::OrderAdd) -> Result<models::OrderAdd200Response, Error<OrderAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_add = order_add;

    let uri_str = format!("{}/order.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Count orders in store
pub async fn order_count(configuration: &configuration::Configuration, order_ids: Option<&str>, ids: Option<&str>, customer_id: Option<&str>, store_id: Option<&str>, customer_email: Option<&str>, order_status: Option<&str>, order_status_ids: Option<Vec<String>>, ebay_order_status: Option<&str>, financial_status: Option<&str>, financial_status_ids: Option<Vec<String>>, fulfillment_channel: Option<&str>, fulfillment_status: Option<&str>, shipping_method: Option<&str>, delivery_method: Option<&str>, tags: Option<&str>, ship_node_type: Option<&str>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>) -> Result<models::OrderCount200Response, Error<OrderCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_ids = order_ids;
    let p_ids = ids;
    let p_customer_id = customer_id;
    let p_store_id = store_id;
    let p_customer_email = customer_email;
    let p_order_status = order_status;
    let p_order_status_ids = order_status_ids;
    let p_ebay_order_status = ebay_order_status;
    let p_financial_status = financial_status;
    let p_financial_status_ids = financial_status_ids;
    let p_fulfillment_channel = fulfillment_channel;
    let p_fulfillment_status = fulfillment_status;
    let p_shipping_method = shipping_method;
    let p_delivery_method = delivery_method;
    let p_tags = tags;
    let p_ship_node_type = ship_node_type;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;

    let uri_str = format!("{}/order.count.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_order_ids {
        req_builder = req_builder.query(&[("order_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_customer_id {
        req_builder = req_builder.query(&[("customer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_customer_email {
        req_builder = req_builder.query(&[("customer_email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_status {
        req_builder = req_builder.query(&[("order_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_status_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("order_status_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("order_status_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_ebay_order_status {
        req_builder = req_builder.query(&[("ebay_order_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_financial_status {
        req_builder = req_builder.query(&[("financial_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_financial_status_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("financial_status_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("financial_status_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_fulfillment_channel {
        req_builder = req_builder.query(&[("fulfillment_channel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fulfillment_status {
        req_builder = req_builder.query(&[("fulfillment_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_shipping_method {
        req_builder = req_builder.query(&[("shipping_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_delivery_method {
        req_builder = req_builder.query(&[("delivery_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ship_node_type {
        req_builder = req_builder.query(&[("ship_node_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve list of financial statuses
pub async fn order_financial_status_list(configuration: &configuration::Configuration, ) -> Result<models::OrderFinancialStatusList200Response, Error<OrderFinancialStatusListError>> {

    let uri_str = format!("{}/order.financial_status.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderFinancialStatusListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This method is deprecated and won't be supported in the future. Please use \"order.list\" instead.
pub async fn order_find(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, customer_id: Option<&str>, customer_email: Option<&str>, order_status: Option<&str>, financial_status: Option<&str>, created_to: Option<&str>, created_from: Option<&str>, modified_to: Option<&str>, modified_from: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::OrderFind200Response, Error<OrderFindError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_customer_id = customer_id;
    let p_customer_email = customer_email;
    let p_order_status = order_status;
    let p_financial_status = financial_status;
    let p_created_to = created_to;
    let p_created_from = created_from;
    let p_modified_to = modified_to;
    let p_modified_from = modified_from;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/order.find.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_customer_id {
        req_builder = req_builder.query(&[("customer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_customer_email {
        req_builder = req_builder.query(&[("customer_email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_status {
        req_builder = req_builder.query(&[("order_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_financial_status {
        req_builder = req_builder.query(&[("financial_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderFindError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve list of fulfillment statuses
pub async fn order_fulfillment_status_list(configuration: &configuration::Configuration, action: Option<&str>) -> Result<models::OrderFulfillmentStatusList200Response, Error<OrderFulfillmentStatusListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_action = action;

    let uri_str = format!("{}/order.fulfillment_status.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderFulfillmentStatusListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Info about a specific order by ID
pub async fn order_info(configuration: &configuration::Configuration, id: Option<&str>, order_id: Option<&str>, store_id: Option<&str>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>, enable_cache: Option<bool>, use_latest_api_version: Option<bool>) -> Result<models::OrderInfo200Response, Error<OrderInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_order_id = order_id;
    let p_store_id = store_id;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;
    let p_enable_cache = enable_cache;
    let p_use_latest_api_version = use_latest_api_version;

    let uri_str = format!("{}/order.info.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_id {
        req_builder = req_builder.query(&[("order_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_enable_cache {
        req_builder = req_builder.query(&[("enable_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_latest_api_version {
        req_builder = req_builder.query(&[("use_latest_api_version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of orders from store.
pub async fn order_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, ids: Option<&str>, order_ids: Option<&str>, since_id: Option<&str>, store_id: Option<&str>, customer_id: Option<&str>, customer_email: Option<&str>, basket_id: Option<&str>, currency_id: Option<&str>, phone: Option<&str>, order_status: Option<&str>, order_status_ids: Option<Vec<String>>, ebay_order_status: Option<&str>, financial_status: Option<&str>, financial_status_ids: Option<Vec<String>>, fulfillment_status: Option<&str>, return_status: Option<&str>, fulfillment_channel: Option<&str>, shipping_method: Option<&str>, skip_order_ids: Option<&str>, is_deleted: Option<bool>, shipping_country_iso3: Option<&str>, delivery_method: Option<&str>, ship_node_type: Option<&str>, created_to: Option<&str>, created_from: Option<&str>, modified_to: Option<&str>, modified_from: Option<&str>, tags: Option<&str>, sort_by: Option<&str>, sort_direction: Option<&str>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>, enable_cache: Option<bool>, use_latest_api_version: Option<bool>) -> Result<models::ModelResponseOrderList, Error<OrderListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_ids = ids;
    let p_order_ids = order_ids;
    let p_since_id = since_id;
    let p_store_id = store_id;
    let p_customer_id = customer_id;
    let p_customer_email = customer_email;
    let p_basket_id = basket_id;
    let p_currency_id = currency_id;
    let p_phone = phone;
    let p_order_status = order_status;
    let p_order_status_ids = order_status_ids;
    let p_ebay_order_status = ebay_order_status;
    let p_financial_status = financial_status;
    let p_financial_status_ids = financial_status_ids;
    let p_fulfillment_status = fulfillment_status;
    let p_return_status = return_status;
    let p_fulfillment_channel = fulfillment_channel;
    let p_shipping_method = shipping_method;
    let p_skip_order_ids = skip_order_ids;
    let p_is_deleted = is_deleted;
    let p_shipping_country_iso3 = shipping_country_iso3;
    let p_delivery_method = delivery_method;
    let p_ship_node_type = ship_node_type;
    let p_created_to = created_to;
    let p_created_from = created_from;
    let p_modified_to = modified_to;
    let p_modified_from = modified_from;
    let p_tags = tags;
    let p_sort_by = sort_by;
    let p_sort_direction = sort_direction;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;
    let p_enable_cache = enable_cache;
    let p_use_latest_api_version = use_latest_api_version;

    let uri_str = format!("{}/order.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_ids {
        req_builder = req_builder.query(&[("order_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since_id {
        req_builder = req_builder.query(&[("since_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_customer_id {
        req_builder = req_builder.query(&[("customer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_customer_email {
        req_builder = req_builder.query(&[("customer_email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_basket_id {
        req_builder = req_builder.query(&[("basket_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_currency_id {
        req_builder = req_builder.query(&[("currency_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_phone {
        req_builder = req_builder.query(&[("phone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_status {
        req_builder = req_builder.query(&[("order_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_status_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("order_status_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("order_status_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_ebay_order_status {
        req_builder = req_builder.query(&[("ebay_order_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_financial_status {
        req_builder = req_builder.query(&[("financial_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_financial_status_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("financial_status_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("financial_status_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_fulfillment_status {
        req_builder = req_builder.query(&[("fulfillment_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_return_status {
        req_builder = req_builder.query(&[("return_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fulfillment_channel {
        req_builder = req_builder.query(&[("fulfillment_channel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_shipping_method {
        req_builder = req_builder.query(&[("shipping_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_order_ids {
        req_builder = req_builder.query(&[("skip_order_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_deleted {
        req_builder = req_builder.query(&[("is_deleted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_shipping_country_iso3 {
        req_builder = req_builder.query(&[("shipping_country_iso3", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_delivery_method {
        req_builder = req_builder.query(&[("delivery_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ship_node_type {
        req_builder = req_builder.query(&[("ship_node_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_enable_cache {
        req_builder = req_builder.query(&[("enable_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_latest_api_version {
        req_builder = req_builder.query(&[("use_latest_api_version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve list of order preestimated shipping methods
pub async fn order_preestimate_shipping_list(configuration: &configuration::Configuration, order_preestimate_shipping_list: models::OrderPreestimateShippingList) -> Result<models::ModelResponseOrderPreestimateShippingList, Error<OrderPreestimateShippingListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_preestimate_shipping_list = order_preestimate_shipping_list;

    let uri_str = format!("{}/order.preestimate_shipping.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_preestimate_shipping_list);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderPreestimateShippingListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a refund to the order.
pub async fn order_refund_add(configuration: &configuration::Configuration, order_refund_add: models::OrderRefundAdd) -> Result<models::OrderRefundAdd200Response, Error<OrderRefundAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_refund_add = order_refund_add;

    let uri_str = format!("{}/order.refund.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_refund_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderRefundAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create new return request.
pub async fn order_return_add(configuration: &configuration::Configuration, order_return_add: models::OrderReturnAdd) -> Result<models::OrderReturnAdd200Response, Error<OrderReturnAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_return_add = order_return_add;

    let uri_str = format!("{}/order.return.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_return_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderReturnAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete return.
pub async fn order_return_delete(configuration: &configuration::Configuration, return_id: &str, order_id: &str, store_id: Option<&str>) -> Result<models::AttributeValueDelete200Response, Error<OrderReturnDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_return_id = return_id;
    let p_order_id = order_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/order.return.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("return_id", &p_return_id.to_string())]);
    req_builder = req_builder.query(&[("order_id", &p_order_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderReturnDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update order's shipment information.
pub async fn order_return_update(configuration: &configuration::Configuration, order_return_update: models::OrderReturnUpdate) -> Result<models::AccountConfigUpdate200Response, Error<OrderReturnUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_return_update = order_return_update;

    let uri_str = format!("{}/order.return.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_return_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderReturnUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a shipment to the order.
pub async fn order_shipment_add(configuration: &configuration::Configuration, order_shipment_add: models::OrderShipmentAdd) -> Result<models::OrderShipmentAdd200Response, Error<OrderShipmentAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_shipment_add = order_shipment_add;

    let uri_str = format!("{}/order.shipment.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_shipment_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderShipmentAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a shipments to the orders.
pub async fn order_shipment_add_batch(configuration: &configuration::Configuration, order_shipment_add_batch: models::OrderShipmentAddBatch) -> Result<models::CategoryAddBatch200Response, Error<OrderShipmentAddBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_shipment_add_batch = order_shipment_add_batch;

    let uri_str = format!("{}/order.shipment.add.batch.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_shipment_add_batch);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderShipmentAddBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete order's shipment.
pub async fn order_shipment_delete(configuration: &configuration::Configuration, shipment_id: &str, order_id: &str, store_id: Option<&str>) -> Result<models::OrderShipmentDelete200Response, Error<OrderShipmentDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_shipment_id = shipment_id;
    let p_order_id = order_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/order.shipment.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("shipment_id", &p_shipment_id.to_string())]);
    req_builder = req_builder.query(&[("order_id", &p_order_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderShipmentDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information of shipment.
pub async fn order_shipment_info(configuration: &configuration::Configuration, id: &str, order_id: &str, start: Option<i32>, store_id: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::OrderShipmentInfo200Response, Error<OrderShipmentInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_order_id = order_id;
    let p_start = start;
    let p_store_id = store_id;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/order.shipment.info.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("order_id", &p_order_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderShipmentInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of shipments per order.
pub async fn order_shipment_list(configuration: &configuration::Configuration, order_id: &str, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, store_id: Option<&str>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseOrderShipmentList, Error<OrderShipmentListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_store_id = store_id;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/order.shipment.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("order_id", &p_order_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderShipmentListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add order shipment's tracking info.
pub async fn order_shipment_tracking_add(configuration: &configuration::Configuration, order_shipment_tracking_add: models::OrderShipmentTrackingAdd) -> Result<models::OrderShipmentTrackingAdd200Response, Error<OrderShipmentTrackingAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_shipment_tracking_add = order_shipment_tracking_add;

    let uri_str = format!("{}/order.shipment.tracking.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_shipment_tracking_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderShipmentTrackingAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update order's shipment information.
pub async fn order_shipment_update(configuration: &configuration::Configuration, order_shipment_update: models::OrderShipmentUpdate) -> Result<models::AccountConfigUpdate200Response, Error<OrderShipmentUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_shipment_update = order_shipment_update;

    let uri_str = format!("{}/order.shipment.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_order_shipment_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderShipmentUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve list of statuses
pub async fn order_status_list(configuration: &configuration::Configuration, store_id: Option<&str>, action: Option<&str>, response_fields: Option<&str>) -> Result<models::ModelResponseOrderStatusList, Error<OrderStatusListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_store_id = store_id;
    let p_action = action;
    let p_response_fields = response_fields;

    let uri_str = format!("{}/order.status.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderStatusListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve list of order transaction
pub async fn order_transaction_list(configuration: &configuration::Configuration, order_ids: &str, count: Option<i32>, page_cursor: Option<&str>, store_id: Option<&str>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseOrderTransactionList, Error<OrderTransactionListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_ids = order_ids;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_store_id = store_id;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;

    let uri_str = format!("{}/order.transaction.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("order_ids", &p_order_ids.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderTransactionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update existing order.
pub async fn order_update(configuration: &configuration::Configuration, order_id: &str, store_id: Option<&str>, order_status: Option<&str>, financial_status: Option<&str>, fulfillment_status: Option<&str>, cancellation_reason: Option<&str>, order_payment_method: Option<&str>, comment: Option<&str>, admin_comment: Option<&str>, admin_private_comment: Option<&str>, invoice_admin_comment: Option<&str>, date_modified: Option<&str>, date_finished: Option<&str>, send_notifications: Option<bool>, create_invoice: Option<bool>, origin: Option<&str>, tags: Option<&str>) -> Result<models::AccountConfigUpdate200Response, Error<OrderUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_order_id = order_id;
    let p_store_id = store_id;
    let p_order_status = order_status;
    let p_financial_status = financial_status;
    let p_fulfillment_status = fulfillment_status;
    let p_cancellation_reason = cancellation_reason;
    let p_order_payment_method = order_payment_method;
    let p_comment = comment;
    let p_admin_comment = admin_comment;
    let p_admin_private_comment = admin_private_comment;
    let p_invoice_admin_comment = invoice_admin_comment;
    let p_date_modified = date_modified;
    let p_date_finished = date_finished;
    let p_send_notifications = send_notifications;
    let p_create_invoice = create_invoice;
    let p_origin = origin;
    let p_tags = tags;

    let uri_str = format!("{}/order.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("order_id", &p_order_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_status {
        req_builder = req_builder.query(&[("order_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_financial_status {
        req_builder = req_builder.query(&[("financial_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fulfillment_status {
        req_builder = req_builder.query(&[("fulfillment_status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cancellation_reason {
        req_builder = req_builder.query(&[("cancellation_reason", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_payment_method {
        req_builder = req_builder.query(&[("order_payment_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_comment {
        req_builder = req_builder.query(&[("comment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_admin_comment {
        req_builder = req_builder.query(&[("admin_comment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_admin_private_comment {
        req_builder = req_builder.query(&[("admin_private_comment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_invoice_admin_comment {
        req_builder = req_builder.query(&[("invoice_admin_comment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_modified {
        req_builder = req_builder.query(&[("date_modified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_finished {
        req_builder = req_builder.query(&[("date_finished", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_send_notifications {
        req_builder = req_builder.query(&[("send_notifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_create_invoice {
        req_builder = req_builder.query(&[("create_invoice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_origin {
        req_builder = req_builder.query(&[("origin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<OrderUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

