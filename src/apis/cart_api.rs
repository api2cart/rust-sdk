/*
 * API2Cart OpenAPI
 *
 * API2Cart
 *
 * The version of the OpenAPI document: 1.1
 * Contact: contact@api2cart.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`cart_bridge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartBridgeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_catalog_price_rules_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartCatalogPriceRulesCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_catalog_price_rules_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartCatalogPriceRulesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_clear_cache`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartClearCacheError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_config_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartConfigUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_coupon_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartCouponAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_coupon_condition_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartCouponConditionAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_coupon_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartCouponCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_coupon_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartCouponDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_coupon_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartCouponListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_disconnect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartDisconnectError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_giftcard_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartGiftcardAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_giftcard_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartGiftcardCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_giftcard_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartGiftcardDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_giftcard_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartGiftcardListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_meta_data_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartMetaDataListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_meta_data_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartMetaDataSetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_meta_data_unset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartMetaDataUnsetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_methods`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartMethodsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_plugin_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartPluginListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_script_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartScriptAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_script_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartScriptDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_script_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartScriptListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_shipping_zones_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartShippingZonesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cart_validate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CartValidateError {
    UnknownValue(serde_json::Value),
}


/// Get bridge key and store key
pub async fn cart_bridge(configuration: &configuration::Configuration, ) -> Result<models::CartBridge200Response, Error<CartBridgeError>> {

    let uri_str = format!("{}/cart.bridge.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartBridgeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get count of cart catalog price rules discounts.
pub async fn cart_catalog_price_rules_count(configuration: &configuration::Configuration, ) -> Result<models::CartCatalogPriceRulesCount200Response, Error<CartCatalogPriceRulesCountError>> {

    let uri_str = format!("{}/cart.catalog_price_rules.count.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartCatalogPriceRulesCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get cart catalog price rules discounts.
pub async fn cart_catalog_price_rules_list(configuration: &configuration::Configuration, page_cursor: Option<&str>, start: Option<i32>, count: Option<i32>, ids: Option<&str>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseCartCatalogPriceRulesList, Error<CartCatalogPriceRulesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_cursor = page_cursor;
    let p_start = start;
    let p_count = count;
    let p_ids = ids;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;

    let uri_str = format!("{}/cart.catalog_price_rules.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartCatalogPriceRulesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clear cache on store.
pub async fn cart_clear_cache(configuration: &configuration::Configuration, cache_type: &str) -> Result<models::CartClearCache200Response, Error<CartClearCacheError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cache_type = cache_type;

    let uri_str = format!("{}/cart.clear_cache.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("cache_type", &p_cache_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartClearCacheError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of cart configs
pub async fn cart_config(configuration: &configuration::Configuration, params: Option<&str>, exclude: Option<&str>) -> Result<models::CartConfig200Response, Error<CartConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/cart.config.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use this API method to update custom data in client database.
pub async fn cart_config_update(configuration: &configuration::Configuration, cart_config_update: models::CartConfigUpdate) -> Result<models::CartConfigUpdate200Response, Error<CartConfigUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cart_config_update = cart_config_update;

    let uri_str = format!("{}/cart.config.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_cart_config_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartConfigUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use this method to create a coupon with specified conditions.
pub async fn cart_coupon_add(configuration: &configuration::Configuration, cart_coupon_add: models::CartCouponAdd) -> Result<models::CartCouponAdd200Response, Error<CartCouponAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cart_coupon_add = cart_coupon_add;

    let uri_str = format!("{}/cart.coupon.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_cart_coupon_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartCouponAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use this method to add additional conditions for coupon application.
pub async fn cart_coupon_condition_add(configuration: &configuration::Configuration, coupon_id: &str, entity: &str, key: &str, operator: &str, value: &str, store_id: Option<&str>, target: Option<&str>, include_tax: Option<bool>, include_shipping: Option<bool>) -> Result<models::BasketLiveShippingServiceDelete200Response, Error<CartCouponConditionAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_coupon_id = coupon_id;
    let p_entity = entity;
    let p_key = key;
    let p_operator = operator;
    let p_value = value;
    let p_store_id = store_id;
    let p_target = target;
    let p_include_tax = include_tax;
    let p_include_shipping = include_shipping;

    let uri_str = format!("{}/cart.coupon.condition.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("coupon_id", &p_coupon_id.to_string())]);
    if let Some(ref param_value) = p_target {
        req_builder = req_builder.query(&[("target", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("entity", &p_entity.to_string())]);
    req_builder = req_builder.query(&[("key", &p_key.to_string())]);
    req_builder = req_builder.query(&[("operator", &p_operator.to_string())]);
    req_builder = req_builder.query(&[("value", &p_value.to_string())]);
    if let Some(ref param_value) = p_include_tax {
        req_builder = req_builder.query(&[("include_tax", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_shipping {
        req_builder = req_builder.query(&[("include_shipping", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartCouponConditionAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This method allows you to get the number of coupons. On some platforms, you can filter the coupons by the date they were active.
pub async fn cart_coupon_count(configuration: &configuration::Configuration, store_id: Option<&str>, date_start_from: Option<&str>, date_start_to: Option<&str>, date_end_from: Option<&str>, date_end_to: Option<&str>, avail: Option<bool>) -> Result<models::CartCouponCount200Response, Error<CartCouponCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_store_id = store_id;
    let p_date_start_from = date_start_from;
    let p_date_start_to = date_start_to;
    let p_date_end_from = date_end_from;
    let p_date_end_to = date_end_to;
    let p_avail = avail;

    let uri_str = format!("{}/cart.coupon.count.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_start_from {
        req_builder = req_builder.query(&[("date_start_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_start_to {
        req_builder = req_builder.query(&[("date_start_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_end_from {
        req_builder = req_builder.query(&[("date_end_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_end_to {
        req_builder = req_builder.query(&[("date_end_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail {
        req_builder = req_builder.query(&[("avail", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartCouponCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete coupon
pub async fn cart_coupon_delete(configuration: &configuration::Configuration, id: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<CartCouponDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_store_id = store_id;

    let uri_str = format!("{}/cart.coupon.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartCouponDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get cart coupon discounts.
pub async fn cart_coupon_list(configuration: &configuration::Configuration, page_cursor: Option<&str>, start: Option<i32>, count: Option<i32>, coupons_ids: Option<&str>, store_id: Option<&str>, date_start_from: Option<&str>, date_start_to: Option<&str>, date_end_from: Option<&str>, date_end_to: Option<&str>, avail: Option<bool>, lang_id: Option<&str>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseCartCouponList, Error<CartCouponListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_cursor = page_cursor;
    let p_start = start;
    let p_count = count;
    let p_coupons_ids = coupons_ids;
    let p_store_id = store_id;
    let p_date_start_from = date_start_from;
    let p_date_start_to = date_start_to;
    let p_date_end_from = date_end_from;
    let p_date_end_to = date_end_to;
    let p_avail = avail;
    let p_lang_id = lang_id;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;

    let uri_str = format!("{}/cart.coupon.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_coupons_ids {
        req_builder = req_builder.query(&[("coupons_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_start_from {
        req_builder = req_builder.query(&[("date_start_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_start_to {
        req_builder = req_builder.query(&[("date_start_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_end_from {
        req_builder = req_builder.query(&[("date_end_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_date_end_to {
        req_builder = req_builder.query(&[("date_end_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail {
        req_builder = req_builder.query(&[("avail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartCouponListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add store to the account
pub async fn cart_create(configuration: &configuration::Configuration, cart_create: models::CartCreate) -> Result<models::AccountCartAdd200Response, Error<CartCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cart_create = cart_create;

    let uri_str = format!("{}/cart.create.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_cart_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove store from API2Cart
pub async fn cart_delete(configuration: &configuration::Configuration, delete_bridge: Option<bool>) -> Result<models::CartDelete200Response, Error<CartDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_delete_bridge = delete_bridge;

    let uri_str = format!("{}/cart.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_delete_bridge {
        req_builder = req_builder.query(&[("delete_bridge", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disconnect with the store and clear store session data.
pub async fn cart_disconnect(configuration: &configuration::Configuration, delete_bridge: Option<bool>) -> Result<models::CartDisconnect200Response, Error<CartDisconnectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_delete_bridge = delete_bridge;

    let uri_str = format!("{}/cart.disconnect.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_delete_bridge {
        req_builder = req_builder.query(&[("delete_bridge", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartDisconnectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use this method to create a gift card for a specified amount.
pub async fn cart_giftcard_add(configuration: &configuration::Configuration, amount: f64, code: Option<&str>, owner_email: Option<&str>, recipient_email: Option<&str>, recipient_name: Option<&str>, owner_name: Option<&str>) -> Result<models::CartGiftcardAdd200Response, Error<CartGiftcardAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_amount = amount;
    let p_code = code;
    let p_owner_email = owner_email;
    let p_recipient_email = recipient_email;
    let p_recipient_name = recipient_name;
    let p_owner_name = owner_name;

    let uri_str = format!("{}/cart.giftcard.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("amount", &p_amount.to_string())]);
    if let Some(ref param_value) = p_code {
        req_builder = req_builder.query(&[("code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_owner_email {
        req_builder = req_builder.query(&[("owner_email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recipient_email {
        req_builder = req_builder.query(&[("recipient_email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_recipient_name {
        req_builder = req_builder.query(&[("recipient_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_owner_name {
        req_builder = req_builder.query(&[("owner_name", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartGiftcardAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get gift cards count.
pub async fn cart_giftcard_count(configuration: &configuration::Configuration, store_id: Option<&str>) -> Result<models::CartGiftcardCount200Response, Error<CartGiftcardCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_store_id = store_id;

    let uri_str = format!("{}/cart.giftcard.count.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartGiftcardCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete giftcard
pub async fn cart_giftcard_delete(configuration: &configuration::Configuration, id: &str) -> Result<models::AttributeDelete200Response, Error<CartGiftcardDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/cart.giftcard.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartGiftcardDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get gift cards list.
pub async fn cart_giftcard_list(configuration: &configuration::Configuration, page_cursor: Option<&str>, start: Option<i32>, count: Option<i32>, store_id: Option<&str>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseCartGiftCardList, Error<CartGiftcardListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_cursor = page_cursor;
    let p_start = start;
    let p_count = count;
    let p_store_id = store_id;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;

    let uri_str = format!("{}/cart.giftcard.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartGiftcardListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This method allows you to get various information about the store, including a list of stores (in the case of a multistore configuration), a list of supported languages, currencies, carriers, warehouses, and many other information. This information contains data that is relatively stable and rarely changes, so API2Cart can cache certain data to reduce the load on the store and speed up the execution of the request. We also recommend that you cache the response of this method on your side to save requests. If you need to clear the cache for a specific store, then use the cart.validate method.
pub async fn cart_info(configuration: &configuration::Configuration, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>, store_id: Option<&str>) -> Result<models::CartInfo200Response, Error<CartInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;
    let p_store_id = store_id;

    let uri_str = format!("{}/cart.info.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of supported carts
pub async fn cart_list(configuration: &configuration::Configuration, ) -> Result<models::CartList200Response, Error<CartListError>> {

    let uri_str = format!("{}/cart.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Using this method, you can get a list of metadata for various entities (products, options, customers, orders). Usually this is data created by third-party plugins.
pub async fn cart_meta_data_list(configuration: &configuration::Configuration, entity_id: &str, entity: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, key: Option<&str>, count: Option<i32>, page_cursor: Option<&str>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseCartMetaDataList, Error<CartMetaDataListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_entity_id = entity_id;
    let p_entity = entity;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_key = key;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;

    let uri_str = format!("{}/cart.meta_data.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("entity_id", &p_entity_id.to_string())]);
    if let Some(ref param_value) = p_entity {
        req_builder = req_builder.query(&[("entity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_key {
        req_builder = req_builder.query(&[("key", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartMetaDataListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set meta data for a specific entity
pub async fn cart_meta_data_set(configuration: &configuration::Configuration, entity_id: &str, key: &str, value: &str, namespace: &str, entity: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>) -> Result<models::AttributeAdd200Response, Error<CartMetaDataSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_entity_id = entity_id;
    let p_key = key;
    let p_value = value;
    let p_namespace = namespace;
    let p_entity = entity;
    let p_store_id = store_id;
    let p_lang_id = lang_id;

    let uri_str = format!("{}/cart.meta_data.set.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("entity_id", &p_entity_id.to_string())]);
    if let Some(ref param_value) = p_entity {
        req_builder = req_builder.query(&[("entity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("key", &p_key.to_string())]);
    req_builder = req_builder.query(&[("value", &p_value.to_string())]);
    req_builder = req_builder.query(&[("namespace", &p_namespace.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartMetaDataSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unset meta data for a specific entity
pub async fn cart_meta_data_unset(configuration: &configuration::Configuration, entity_id: &str, key: &str, id: &str, entity: Option<&str>, store_id: Option<&str>) -> Result<models::BasketLiveShippingServiceDelete200Response, Error<CartMetaDataUnsetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_entity_id = entity_id;
    let p_key = key;
    let p_id = id;
    let p_entity = entity;
    let p_store_id = store_id;

    let uri_str = format!("{}/cart.meta_data.unset.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("entity_id", &p_entity_id.to_string())]);
    if let Some(ref param_value) = p_entity {
        req_builder = req_builder.query(&[("entity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("key", &p_key.to_string())]);
    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartMetaDataUnsetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of supported API methods.
pub async fn cart_methods(configuration: &configuration::Configuration, ) -> Result<models::CartMethods200Response, Error<CartMethodsError>> {

    let uri_str = format!("{}/cart.methods.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartMethodsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of third-party plugins installed on the store.
pub async fn cart_plugin_list(configuration: &configuration::Configuration, store_id: Option<&str>, start: Option<i32>, count: Option<i32>) -> Result<models::CartPluginList200Response, Error<CartPluginListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_store_id = store_id;
    let p_start = start;
    let p_count = count;

    let uri_str = format!("{}/cart.plugin.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartPluginListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add new script to the storefront
pub async fn cart_script_add(configuration: &configuration::Configuration, name: Option<&str>, description: Option<&str>, html: Option<&str>, src: Option<&str>, load_method: Option<&str>, scope: Option<&str>, events: Option<&str>, store_id: Option<&str>) -> Result<models::CartScriptAdd200Response, Error<CartScriptAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_description = description;
    let p_html = html;
    let p_src = src;
    let p_load_method = load_method;
    let p_scope = scope;
    let p_events = events;
    let p_store_id = store_id;

    let uri_str = format!("{}/cart.script.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_html {
        req_builder = req_builder.query(&[("html", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_src {
        req_builder = req_builder.query(&[("src", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_load_method {
        req_builder = req_builder.query(&[("load_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scope {
        req_builder = req_builder.query(&[("scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_events {
        req_builder = req_builder.query(&[("events", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartScriptAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove script from the storefront
pub async fn cart_script_delete(configuration: &configuration::Configuration, id: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<CartScriptDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_store_id = store_id;

    let uri_str = format!("{}/cart.script.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartScriptDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get scripts installed to the storefront
pub async fn cart_script_list(configuration: &configuration::Configuration, page_cursor: Option<&str>, start: Option<i32>, count: Option<i32>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, script_ids: Option<&str>, store_id: Option<&str>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseCartScriptList, Error<CartScriptListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page_cursor = page_cursor;
    let p_start = start;
    let p_count = count;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_script_ids = script_ids;
    let p_store_id = store_id;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;

    let uri_str = format!("{}/cart.script.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_script_ids {
        req_builder = req_builder.query(&[("script_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartScriptListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of shipping zones
pub async fn cart_shipping_zones_list(configuration: &configuration::Configuration, store_id: Option<&str>, start: Option<i32>, count: Option<i32>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseCartShippingZonesList, Error<CartShippingZonesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_store_id = store_id;
    let p_start = start;
    let p_count = count;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;

    let uri_str = format!("{}/cart.shipping_zones.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartShippingZonesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This method clears the cache in API2Cart for a particular store and checks whether the connection to the store is available. Use this method if there have been any changes in the settings on the storе, for example, if a new plugin has been installed or removed.
pub async fn cart_validate(configuration: &configuration::Configuration, validate_version: Option<bool>) -> Result<models::CartValidate200Response, Error<CartValidateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_validate_version = validate_version;

    let uri_str = format!("{}/cart.validate.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_validate_version {
        req_builder = req_builder.query(&[("validate_version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CartValidateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

