/*
 * API2Cart OpenAPI
 *
 * API2Cart
 *
 * The version of the OpenAPI document: 1.1
 * Contact: contact@api2cart.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`product_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_add_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductAddBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_attribute_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductAttributeListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_attribute_value_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductAttributeValueSetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_attribute_value_unset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductAttributeValueUnsetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_brand_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductBrandListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_child_item_find`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductChildItemFindError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_child_item_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductChildItemInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_child_item_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductChildItemListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_currency_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductCurrencyAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_currency_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductCurrencyListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_delete_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductDeleteBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_fields`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductFieldsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_find`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductFindError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_image_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductImageAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_image_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductImageDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_image_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductImageUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_manufacturer_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductManufacturerAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_option_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductOptionAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_option_assign`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductOptionAssignError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_option_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductOptionDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_option_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductOptionListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_option_value_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductOptionValueAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_option_value_assign`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductOptionValueAssignError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_option_value_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductOptionValueDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_option_value_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductOptionValueUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_price_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductPriceAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_price_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductPriceDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_price_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductPriceUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_review_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductReviewListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_store_assign`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductStoreAssignError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_tax_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductTaxAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_update_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductUpdateBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_add_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantAddBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_delete_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantDeleteBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_image_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantImageAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_image_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantImageDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_price_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantPriceAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_price_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantPriceDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_price_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantPriceUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`product_variant_update_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductVariantUpdateBatchError {
    UnknownValue(serde_json::Value),
}


/// Add new product to store.
pub async fn product_add(configuration: &configuration::Configuration, product_add: models::ProductAdd) -> Result<models::ProductAdd200Response, Error<ProductAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_add = product_add;

    let uri_str = format!("{}/product.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add new products to the store.
pub async fn product_add_batch(configuration: &configuration::Configuration, product_add_batch: models::ProductAddBatch) -> Result<models::CategoryAddBatch200Response, Error<ProductAddBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_add_batch = product_add_batch;

    let uri_str = format!("{}/product.add.batch.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_add_batch);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductAddBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of attributes and values.
pub async fn product_attribute_list(configuration: &configuration::Configuration, product_id: &str, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, attribute_id: Option<&str>, variant_id: Option<&str>, attribute_group_id: Option<&str>, lang_id: Option<&str>, store_id: Option<&str>, set_name: Option<&str>, sort_by: Option<&str>, sort_direction: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseProductAttributeList, Error<ProductAttributeListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_attribute_id = attribute_id;
    let p_variant_id = variant_id;
    let p_attribute_group_id = attribute_group_id;
    let p_lang_id = lang_id;
    let p_store_id = store_id;
    let p_set_name = set_name;
    let p_sort_by = sort_by;
    let p_sort_direction = sort_direction;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/product.attribute.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_attribute_id {
        req_builder = req_builder.query(&[("attribute_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_variant_id {
        req_builder = req_builder.query(&[("variant_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attribute_group_id {
        req_builder = req_builder.query(&[("attribute_group_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_set_name {
        req_builder = req_builder.query(&[("set_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductAttributeListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set attribute value to product.
pub async fn product_attribute_value_set(configuration: &configuration::Configuration, product_id: &str, attribute_id: Option<&str>, attribute_group_id: Option<&str>, attribute_name: Option<&str>, value: Option<&str>, value_id: Option<i32>, lang_id: Option<&str>, store_id: Option<&str>) -> Result<models::ProductAttributeValueSet200Response, Error<ProductAttributeValueSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_attribute_id = attribute_id;
    let p_attribute_group_id = attribute_group_id;
    let p_attribute_name = attribute_name;
    let p_value = value;
    let p_value_id = value_id;
    let p_lang_id = lang_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.attribute.value.set.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_attribute_id {
        req_builder = req_builder.query(&[("attribute_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attribute_group_id {
        req_builder = req_builder.query(&[("attribute_group_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attribute_name {
        req_builder = req_builder.query(&[("attribute_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_value {
        req_builder = req_builder.query(&[("value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_value_id {
        req_builder = req_builder.query(&[("value_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductAttributeValueSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes attribute value for a product.
pub async fn product_attribute_value_unset(configuration: &configuration::Configuration, product_id: &str, attribute_id: &str, store_id: Option<&str>, include_default: Option<bool>, reindex: Option<bool>, clear_cache: Option<bool>) -> Result<models::ProductAttributeValueUnset200Response, Error<ProductAttributeValueUnsetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_attribute_id = attribute_id;
    let p_store_id = store_id;
    let p_include_default = include_default;
    let p_reindex = reindex;
    let p_clear_cache = clear_cache;

    let uri_str = format!("{}/product.attribute.value.unset.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("attribute_id", &p_attribute_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_default {
        req_builder = req_builder.query(&[("include_default", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_reindex {
        req_builder = req_builder.query(&[("reindex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_clear_cache {
        req_builder = req_builder.query(&[("clear_cache", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductAttributeValueUnsetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of brands from your store.
pub async fn product_brand_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, brand_ids: Option<&str>, category_id: Option<&str>, parent_id: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, find_where: Option<&str>, find_value: Option<&str>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseProductBrandList, Error<ProductBrandListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_brand_ids = brand_ids;
    let p_category_id = category_id;
    let p_parent_id = parent_id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_find_where = find_where;
    let p_find_value = find_value;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/product.brand.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_brand_ids {
        req_builder = req_builder.query(&[("brand_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_category_id {
        req_builder = req_builder.query(&[("category_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_id {
        req_builder = req_builder.query(&[("parent_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_value {
        req_builder = req_builder.query(&[("find_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductBrandListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search product child item (bundled item or configurable product variant) in store catalog.
pub async fn product_child_item_find(configuration: &configuration::Configuration, find_value: Option<&str>, find_where: Option<&str>, find_params: Option<&str>, store_id: Option<&str>) -> Result<models::ProductChildItemFind200Response, Error<ProductChildItemFindError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_find_value = find_value;
    let p_find_where = find_where;
    let p_find_params = find_params;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.child_item.find.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_find_value {
        req_builder = req_builder.query(&[("find_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_params {
        req_builder = req_builder.query(&[("find_params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductChildItemFindError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get child for specific product.
pub async fn product_child_item_info(configuration: &configuration::Configuration, product_id: &str, id: &str, store_id: Option<&str>, lang_id: Option<&str>, currency_id: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>, use_latest_api_version: Option<bool>) -> Result<models::ProductChildItemInfo200Response, Error<ProductChildItemInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_id = id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_currency_id = currency_id;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;
    let p_use_latest_api_version = use_latest_api_version;

    let uri_str = format!("{}/product.child_item.info.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_currency_id {
        req_builder = req_builder.query(&[("currency_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_latest_api_version {
        req_builder = req_builder.query(&[("use_latest_api_version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductChildItemInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of a product's child items, such as variants or bundle components. The total_count field in the response indicates the total number of items in the context of the current filter.
pub async fn product_child_item_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, product_id: Option<&str>, product_ids: Option<&str>, sku: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, currency_id: Option<&str>, avail_sale: Option<bool>, find_value: Option<&str>, find_where: Option<&str>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, return_global: Option<bool>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>, report_request_id: Option<&str>, disable_report_cache: Option<bool>, use_latest_api_version: Option<bool>) -> Result<models::ModelResponseProductChildItemList, Error<ProductChildItemListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_product_id = product_id;
    let p_product_ids = product_ids;
    let p_sku = sku;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_currency_id = currency_id;
    let p_avail_sale = avail_sale;
    let p_find_value = find_value;
    let p_find_where = find_where;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_return_global = return_global;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;
    let p_report_request_id = report_request_id;
    let p_disable_report_cache = disable_report_cache;
    let p_use_latest_api_version = use_latest_api_version;

    let uri_str = format!("{}/product.child_item.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_id {
        req_builder = req_builder.query(&[("product_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_ids {
        req_builder = req_builder.query(&[("product_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sku {
        req_builder = req_builder.query(&[("sku", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_currency_id {
        req_builder = req_builder.query(&[("currency_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail_sale {
        req_builder = req_builder.query(&[("avail_sale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_value {
        req_builder = req_builder.query(&[("find_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_return_global {
        req_builder = req_builder.query(&[("return_global", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_report_request_id {
        req_builder = req_builder.query(&[("report_request_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_report_cache {
        req_builder = req_builder.query(&[("disable_report_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_latest_api_version {
        req_builder = req_builder.query(&[("use_latest_api_version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductChildItemListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Count products in store.
pub async fn product_count(configuration: &configuration::Configuration, product_ids: Option<&str>, since_id: Option<&str>, categories_ids: Option<&str>, category_id: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, avail_view: Option<bool>, avail_sale: Option<bool>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, brand_name: Option<&str>, product_attributes: Option<Vec<String>>, status: Option<&str>, r#type: Option<&str>, find_value: Option<&str>, find_where: Option<&str>, report_request_id: Option<&str>, return_global: Option<bool>, disable_report_cache: Option<bool>, use_latest_api_version: Option<bool>) -> Result<models::ProductCount200Response, Error<ProductCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_ids = product_ids;
    let p_since_id = since_id;
    let p_categories_ids = categories_ids;
    let p_category_id = category_id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_avail_view = avail_view;
    let p_avail_sale = avail_sale;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_brand_name = brand_name;
    let p_product_attributes = product_attributes;
    let p_status = status;
    let p_type = r#type;
    let p_find_value = find_value;
    let p_find_where = find_where;
    let p_report_request_id = report_request_id;
    let p_return_global = return_global;
    let p_disable_report_cache = disable_report_cache;
    let p_use_latest_api_version = use_latest_api_version;

    let uri_str = format!("{}/product.count.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_product_ids {
        req_builder = req_builder.query(&[("product_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since_id {
        req_builder = req_builder.query(&[("since_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_categories_ids {
        req_builder = req_builder.query(&[("categories_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_category_id {
        req_builder = req_builder.query(&[("category_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail_view {
        req_builder = req_builder.query(&[("avail_view", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail_sale {
        req_builder = req_builder.query(&[("avail_sale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_brand_name {
        req_builder = req_builder.query(&[("brand_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_attributes {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("product_attributes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("product_attributes", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_value {
        req_builder = req_builder.query(&[("find_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_report_request_id {
        req_builder = req_builder.query(&[("report_request_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_return_global {
        req_builder = req_builder.query(&[("return_global", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_report_cache {
        req_builder = req_builder.query(&[("disable_report_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_latest_api_version {
        req_builder = req_builder.query(&[("use_latest_api_version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add currency and/or set default in store
pub async fn product_currency_add(configuration: &configuration::Configuration, iso3: &str, rate: f64, name: Option<&str>, avail: Option<bool>, symbol_left: Option<&str>, symbol_right: Option<&str>, default: Option<bool>) -> Result<models::ProductCurrencyAdd200Response, Error<ProductCurrencyAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iso3 = iso3;
    let p_rate = rate;
    let p_name = name;
    let p_avail = avail;
    let p_symbol_left = symbol_left;
    let p_symbol_right = symbol_right;
    let p_default = default;

    let uri_str = format!("{}/product.currency.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("iso3", &p_iso3.to_string())]);
    req_builder = req_builder.query(&[("rate", &p_rate.to_string())]);
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail {
        req_builder = req_builder.query(&[("avail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_symbol_left {
        req_builder = req_builder.query(&[("symbol_left", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_symbol_right {
        req_builder = req_builder.query(&[("symbol_right", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_default {
        req_builder = req_builder.query(&[("default", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductCurrencyAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of currencies
pub async fn product_currency_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, default: Option<bool>, avail: Option<bool>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseProductCurrencyList, Error<ProductCurrencyListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_default = default;
    let p_avail = avail;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/product.currency.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_default {
        req_builder = req_builder.query(&[("default", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail {
        req_builder = req_builder.query(&[("avail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductCurrencyListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Product delete
pub async fn product_delete(configuration: &configuration::Configuration, id: &str, store_id: Option<&str>) -> Result<models::CustomerDelete200Response, Error<ProductDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove product from the store.
pub async fn product_delete_batch(configuration: &configuration::Configuration, product_delete_batch: models::ProductDeleteBatch) -> Result<models::CategoryAddBatch200Response, Error<ProductDeleteBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_delete_batch = product_delete_batch;

    let uri_str = format!("{}/product.delete.batch.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_delete_batch);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductDeleteBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve all available fields for product item in store.
pub async fn product_fields(configuration: &configuration::Configuration, ) -> Result<models::CartConfigUpdate200Response, Error<ProductFieldsError>> {

    let uri_str = format!("{}/product.fields.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductFieldsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search product in store catalog. \"Apple\" is specified here by default.
pub async fn product_find(configuration: &configuration::Configuration, find_value: &str, find_where: Option<&str>, find_params: Option<&str>, find_what: Option<&str>, lang_id: Option<&str>, store_id: Option<&str>) -> Result<models::ProductFind200Response, Error<ProductFindError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_find_value = find_value;
    let p_find_where = find_where;
    let p_find_params = find_params;
    let p_find_what = find_what;
    let p_lang_id = lang_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.find.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("find_value", &p_find_value.to_string())]);
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_params {
        req_builder = req_builder.query(&[("find_params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_what {
        req_builder = req_builder.query(&[("find_what", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductFindError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add image to product
pub async fn product_image_add(configuration: &configuration::Configuration, product_image_add: models::ProductImageAdd) -> Result<models::ProductImageAdd200Response, Error<ProductImageAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_image_add = product_image_add;

    let uri_str = format!("{}/product.image.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_image_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductImageAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete image
pub async fn product_image_delete(configuration: &configuration::Configuration, product_id: &str, id: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<ProductImageDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_id = id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.image.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductImageDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update details of image
pub async fn product_image_update(configuration: &configuration::Configuration, product_id: &str, id: &str, variant_ids: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, image_name: Option<&str>, r#type: Option<&str>, label: Option<&str>, position: Option<i32>, hidden: Option<bool>) -> Result<models::ProductImageUpdate200Response, Error<ProductImageUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_id = id;
    let p_variant_ids = variant_ids;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_image_name = image_name;
    let p_type = r#type;
    let p_label = label;
    let p_position = position;
    let p_hidden = hidden;

    let uri_str = format!("{}/product.image.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_variant_ids {
        req_builder = req_builder.query(&[("variant_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_image_name {
        req_builder = req_builder.query(&[("image_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_label {
        req_builder = req_builder.query(&[("label", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_position {
        req_builder = req_builder.query(&[("position", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_hidden {
        req_builder = req_builder.query(&[("hidden", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductImageUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information about a specific product by its ID. In the case of a multistore configuration, use the store_id filter to get a response in the context of a specific store.
pub async fn product_info(configuration: &configuration::Configuration, id: &str, store_id: Option<&str>, lang_id: Option<&str>, currency_id: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>, report_request_id: Option<&str>, disable_report_cache: Option<bool>, use_latest_api_version: Option<bool>) -> Result<models::ProductInfo200Response, Error<ProductInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_currency_id = currency_id;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;
    let p_report_request_id = report_request_id;
    let p_disable_report_cache = disable_report_cache;
    let p_use_latest_api_version = use_latest_api_version;

    let uri_str = format!("{}/product.info.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_currency_id {
        req_builder = req_builder.query(&[("currency_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_report_request_id {
        req_builder = req_builder.query(&[("report_request_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_report_cache {
        req_builder = req_builder.query(&[("disable_report_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_latest_api_version {
        req_builder = req_builder.query(&[("use_latest_api_version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of products from your store. Returns 10 products by default.
pub async fn product_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, product_ids: Option<&str>, since_id: Option<&str>, categories_ids: Option<&str>, category_id: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, currency_id: Option<&str>, avail_view: Option<bool>, avail_sale: Option<bool>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, sku: Option<&str>, brand_name: Option<&str>, product_attributes: Option<Vec<String>>, status: Option<&str>, r#type: Option<&str>, find_value: Option<&str>, find_where: Option<&str>, return_global: Option<bool>, params: Option<&str>, response_fields: Option<&str>, exclude: Option<&str>, sort_by: Option<&str>, sort_direction: Option<&str>, report_request_id: Option<&str>, disable_cache: Option<bool>, disable_report_cache: Option<bool>, use_latest_api_version: Option<bool>) -> Result<models::ModelResponseProductList, Error<ProductListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_product_ids = product_ids;
    let p_since_id = since_id;
    let p_categories_ids = categories_ids;
    let p_category_id = category_id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_currency_id = currency_id;
    let p_avail_view = avail_view;
    let p_avail_sale = avail_sale;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_sku = sku;
    let p_brand_name = brand_name;
    let p_product_attributes = product_attributes;
    let p_status = status;
    let p_type = r#type;
    let p_find_value = find_value;
    let p_find_where = find_where;
    let p_return_global = return_global;
    let p_params = params;
    let p_response_fields = response_fields;
    let p_exclude = exclude;
    let p_sort_by = sort_by;
    let p_sort_direction = sort_direction;
    let p_report_request_id = report_request_id;
    let p_disable_cache = disable_cache;
    let p_disable_report_cache = disable_report_cache;
    let p_use_latest_api_version = use_latest_api_version;

    let uri_str = format!("{}/product.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_ids {
        req_builder = req_builder.query(&[("product_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_since_id {
        req_builder = req_builder.query(&[("since_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_categories_ids {
        req_builder = req_builder.query(&[("categories_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_category_id {
        req_builder = req_builder.query(&[("category_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_currency_id {
        req_builder = req_builder.query(&[("currency_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail_view {
        req_builder = req_builder.query(&[("avail_view", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail_sale {
        req_builder = req_builder.query(&[("avail_sale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sku {
        req_builder = req_builder.query(&[("sku", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_brand_name {
        req_builder = req_builder.query(&[("brand_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_attributes {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("product_attributes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("product_attributes", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_value {
        req_builder = req_builder.query(&[("find_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_return_global {
        req_builder = req_builder.query(&[("return_global", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_report_request_id {
        req_builder = req_builder.query(&[("report_request_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_cache {
        req_builder = req_builder.query(&[("disable_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_report_cache {
        req_builder = req_builder.query(&[("disable_report_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_latest_api_version {
        req_builder = req_builder.query(&[("use_latest_api_version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add manufacturer to store and assign to product
pub async fn product_manufacturer_add(configuration: &configuration::Configuration, product_id: &str, manufacturer: &str, store_id: Option<&str>) -> Result<models::ProductManufacturerAdd200Response, Error<ProductManufacturerAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_manufacturer = manufacturer;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.manufacturer.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("manufacturer", &p_manufacturer.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductManufacturerAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add product option from store.
pub async fn product_option_add(configuration: &configuration::Configuration, product_option_add: models::ProductOptionAdd) -> Result<models::ProductOptionAdd200Response, Error<ProductOptionAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_option_add = product_option_add;

    let uri_str = format!("{}/product.option.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_option_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductOptionAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign option from product.
pub async fn product_option_assign(configuration: &configuration::Configuration, product_id: &str, option_id: &str, required: Option<bool>, sort_order: Option<i32>, option_values: Option<&str>, clear_cache: Option<bool>) -> Result<models::ProductOptionAssign200Response, Error<ProductOptionAssignError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_option_id = option_id;
    let p_required = required;
    let p_sort_order = sort_order;
    let p_option_values = option_values;
    let p_clear_cache = clear_cache;

    let uri_str = format!("{}/product.option.assign.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("option_id", &p_option_id.to_string())]);
    if let Some(ref param_value) = p_required {
        req_builder = req_builder.query(&[("required", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_option_values {
        req_builder = req_builder.query(&[("option_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_clear_cache {
        req_builder = req_builder.query(&[("clear_cache", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductOptionAssignError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Product option delete.
pub async fn product_option_delete(configuration: &configuration::Configuration, option_id: &str, product_id: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<ProductOptionDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_option_id = option_id;
    let p_product_id = product_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.option.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("option_id", &p_option_id.to_string())]);
    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductOptionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of options.
pub async fn product_option_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, product_id: Option<&str>, lang_id: Option<&str>, store_id: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseProductOptionList, Error<ProductOptionListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_product_id = product_id;
    let p_lang_id = lang_id;
    let p_store_id = store_id;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/product.option.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_id {
        req_builder = req_builder.query(&[("product_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductOptionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add product option item from option.
pub async fn product_option_value_add(configuration: &configuration::Configuration, product_id: &str, option_id: &str, option_value: Option<&str>, sort_order: Option<i32>, display_value: Option<&str>, is_default: Option<bool>, clear_cache: Option<bool>) -> Result<models::ProductOptionValueAdd200Response, Error<ProductOptionValueAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_option_id = option_id;
    let p_option_value = option_value;
    let p_sort_order = sort_order;
    let p_display_value = display_value;
    let p_is_default = is_default;
    let p_clear_cache = clear_cache;

    let uri_str = format!("{}/product.option.value.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("option_id", &p_option_id.to_string())]);
    if let Some(ref param_value) = p_option_value {
        req_builder = req_builder.query(&[("option_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_display_value {
        req_builder = req_builder.query(&[("display_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_default {
        req_builder = req_builder.query(&[("is_default", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_clear_cache {
        req_builder = req_builder.query(&[("clear_cache", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductOptionValueAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign product option item from product.
pub async fn product_option_value_assign(configuration: &configuration::Configuration, product_option_id: i32, option_value_id: &str, clear_cache: Option<bool>) -> Result<models::ProductOptionValueAssign200Response, Error<ProductOptionValueAssignError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_option_id = product_option_id;
    let p_option_value_id = option_value_id;
    let p_clear_cache = clear_cache;

    let uri_str = format!("{}/product.option.value.assign.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("product_option_id", &p_product_option_id.to_string())]);
    req_builder = req_builder.query(&[("option_value_id", &p_option_value_id.to_string())]);
    if let Some(ref param_value) = p_clear_cache {
        req_builder = req_builder.query(&[("clear_cache", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductOptionValueAssignError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Product option value delete.
pub async fn product_option_value_delete(configuration: &configuration::Configuration, option_id: &str, option_value_id: &str, product_id: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<ProductOptionValueDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_option_id = option_id;
    let p_option_value_id = option_value_id;
    let p_product_id = product_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.option.value.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("option_id", &p_option_id.to_string())]);
    req_builder = req_builder.query(&[("option_value_id", &p_option_value_id.to_string())]);
    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductOptionValueDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update product option item from option.
pub async fn product_option_value_update(configuration: &configuration::Configuration, product_id: &str, option_id: &str, option_value_id: &str, option_value: Option<&str>, price: Option<f64>, quantity: Option<f64>, display_value: Option<&str>, clear_cache: Option<bool>) -> Result<models::AccountConfigUpdate200Response, Error<ProductOptionValueUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_option_id = option_id;
    let p_option_value_id = option_value_id;
    let p_option_value = option_value;
    let p_price = price;
    let p_quantity = quantity;
    let p_display_value = display_value;
    let p_clear_cache = clear_cache;

    let uri_str = format!("{}/product.option.value.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("option_id", &p_option_id.to_string())]);
    req_builder = req_builder.query(&[("option_value_id", &p_option_value_id.to_string())]);
    if let Some(ref param_value) = p_option_value {
        req_builder = req_builder.query(&[("option_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_price {
        req_builder = req_builder.query(&[("price", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quantity {
        req_builder = req_builder.query(&[("quantity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_display_value {
        req_builder = req_builder.query(&[("display_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_clear_cache {
        req_builder = req_builder.query(&[("clear_cache", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductOptionValueUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add some prices to the product.
pub async fn product_price_add(configuration: &configuration::Configuration, product_price_add: models::ProductPriceAdd) -> Result<models::CartValidate200Response, Error<ProductPriceAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_price_add = product_price_add;

    let uri_str = format!("{}/product.price.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_price_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductPriceAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete some prices of the product
pub async fn product_price_delete(configuration: &configuration::Configuration, product_id: &str, group_prices: Option<&str>, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<ProductPriceDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_group_prices = group_prices;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.price.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_group_prices {
        req_builder = req_builder.query(&[("group_prices", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductPriceDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update some prices of the product.
pub async fn product_price_update(configuration: &configuration::Configuration, product_price_update: models::ProductPriceUpdate) -> Result<models::AccountConfigUpdate200Response, Error<ProductPriceUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_price_update = product_price_update;

    let uri_str = format!("{}/product.price.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_price_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductPriceUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get reviews of a specific product.
pub async fn product_review_list(configuration: &configuration::Configuration, product_id: &str, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, ids: Option<&str>, store_id: Option<&str>, status: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ModelResponseProductReviewList, Error<ProductReviewListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_ids = ids;
    let p_store_id = store_id;
    let p_status = status;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/product.review.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductReviewListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign product to store
pub async fn product_store_assign(configuration: &configuration::Configuration, product_id: &str, store_id: &str) -> Result<models::AccountConfigUpdate200Response, Error<ProductStoreAssignError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.store.assign.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("store_id", &p_store_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductStoreAssignError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add tax class and tax rate to store and assign to product.
pub async fn product_tax_add(configuration: &configuration::Configuration, product_tax_add: models::ProductTaxAdd) -> Result<models::ProductTaxAdd200Response, Error<ProductTaxAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_tax_add = product_tax_add;

    let uri_str = format!("{}/product.tax.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_tax_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductTaxAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This method can be used to update certain product data. The list of supported parameters depends on the specific platform. Please transmit only those parameters that are supported by the particular platform. Please note that to update the product quantity, it is recommended to use relative parameters (increase_quantity or reduce_quantity) to avoid unexpected overwrites on heavily loaded stores.
pub async fn product_update(configuration: &configuration::Configuration, product_update: models::ProductUpdate) -> Result<models::AccountConfigUpdate200Response, Error<ProductUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_update = product_update;

    let uri_str = format!("{}/product.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update products on the store.
pub async fn product_update_batch(configuration: &configuration::Configuration, product_update_batch: models::ProductUpdateBatch) -> Result<models::CategoryAddBatch200Response, Error<ProductUpdateBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_update_batch = product_update_batch;

    let uri_str = format!("{}/product.update.batch.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_update_batch);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductUpdateBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add variant to product.
pub async fn product_variant_add(configuration: &configuration::Configuration, product_variant_add: models::ProductVariantAdd) -> Result<models::ProductVariantAdd200Response, Error<ProductVariantAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_variant_add = product_variant_add;

    let uri_str = format!("{}/product.variant.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_variant_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add new product variants to the store.
pub async fn product_variant_add_batch(configuration: &configuration::Configuration, product_variant_add_batch: models::ProductVariantAddBatch) -> Result<models::CategoryAddBatch200Response, Error<ProductVariantAddBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_variant_add_batch = product_variant_add_batch;

    let uri_str = format!("{}/product.variant.add.batch.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_variant_add_batch);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantAddBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get count variants.
pub async fn product_variant_count(configuration: &configuration::Configuration, product_id: &str, category_id: Option<&str>, store_id: Option<&str>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>) -> Result<models::ProductVariantCount200Response, Error<ProductVariantCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_category_id = category_id;
    let p_store_id = store_id;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;

    let uri_str = format!("{}/product.variant.count.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_category_id {
        req_builder = req_builder.query(&[("category_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete variant.
pub async fn product_variant_delete(configuration: &configuration::Configuration, id: &str, product_id: &str, store_id: Option<&str>) -> Result<models::AttributeValueDelete200Response, Error<ProductVariantDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_product_id = product_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.variant.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove product variants from the store.
pub async fn product_variant_delete_batch(configuration: &configuration::Configuration, product_variant_delete_batch: models::ProductVariantDeleteBatch) -> Result<models::CategoryAddBatch200Response, Error<ProductVariantDeleteBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_variant_delete_batch = product_variant_delete_batch;

    let uri_str = format!("{}/product.variant.delete.batch.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_variant_delete_batch);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantDeleteBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add image to product
pub async fn product_variant_image_add(configuration: &configuration::Configuration, product_variant_image_add: models::ProductVariantImageAdd) -> Result<models::ProductVariantImageAdd200Response, Error<ProductVariantImageAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_variant_image_add = product_variant_image_add;

    let uri_str = format!("{}/product.variant.image.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_variant_image_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantImageAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete  image to product
pub async fn product_variant_image_delete(configuration: &configuration::Configuration, product_id: &str, product_variant_id: &str, id: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<ProductVariantImageDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_id = product_id;
    let p_product_variant_id = product_variant_id;
    let p_id = id;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.variant.image.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("product_variant_id", &p_product_variant_id.to_string())]);
    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantImageDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get variant info. This method is deprecated, and its development is stopped. Please use \"product.child_item.info\" instead.
pub async fn product_variant_info(configuration: &configuration::Configuration, id: &str, store_id: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ProductInfo200Response, Error<ProductVariantInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_store_id = store_id;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/product.variant.info.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of variants. This method is deprecated, and its development is stopped. Please use \"product.child_item.list\" instead.
pub async fn product_variant_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, product_id: Option<&str>, category_id: Option<&str>, store_id: Option<&str>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, params: Option<&str>, exclude: Option<&str>) -> Result<models::ProductVariantList200Response, Error<ProductVariantListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_product_id = product_id;
    let p_category_id = category_id;
    let p_store_id = store_id;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_params = params;
    let p_exclude = exclude;

    let uri_str = format!("{}/product.variant.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_id {
        req_builder = req_builder.query(&[("product_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_category_id {
        req_builder = req_builder.query(&[("category_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add some prices to the product variant.
pub async fn product_variant_price_add(configuration: &configuration::Configuration, product_variant_price_add: models::ProductVariantPriceAdd) -> Result<models::CartValidate200Response, Error<ProductVariantPriceAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_variant_price_add = product_variant_price_add;

    let uri_str = format!("{}/product.variant.price.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_variant_price_add);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantPriceAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete some prices of the product variant.
pub async fn product_variant_price_delete(configuration: &configuration::Configuration, id: &str, product_id: &str, group_prices: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<ProductVariantPriceDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_product_id = product_id;
    let p_group_prices = group_prices;
    let p_store_id = store_id;

    let uri_str = format!("{}/product.variant.price.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    req_builder = req_builder.query(&[("group_prices", &p_group_prices.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantPriceDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update some prices of the product variant.
pub async fn product_variant_price_update(configuration: &configuration::Configuration, product_variant_price_update: models::ProductVariantPriceUpdate) -> Result<models::AccountConfigUpdate200Response, Error<ProductVariantPriceUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_variant_price_update = product_variant_price_update;

    let uri_str = format!("{}/product.variant.price.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_variant_price_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantPriceUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update variant.
pub async fn product_variant_update(configuration: &configuration::Configuration, product_variant_update: models::ProductVariantUpdate) -> Result<models::AccountConfigUpdate200Response, Error<ProductVariantUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_variant_update = product_variant_update;

    let uri_str = format!("{}/product.variant.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_variant_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update products variants on the store.
pub async fn product_variant_update_batch(configuration: &configuration::Configuration, product_variant_update_batch: models::ProductVariantUpdateBatch) -> Result<models::CategoryAddBatch200Response, Error<ProductVariantUpdateBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_product_variant_update_batch = product_variant_update_batch;

    let uri_str = format!("{}/product.variant.update.batch.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_product_variant_update_batch);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProductVariantUpdateBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

