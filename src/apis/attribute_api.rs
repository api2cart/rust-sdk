/*
 * API2Cart OpenAPI
 *
 * API2Cart
 *
 * The version of the OpenAPI document: 1.1
 * Contact: contact@api2cart.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`attribute_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_assign_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeAssignGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_assign_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeAssignSetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_attributeset_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeAttributesetListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_group_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeGroupListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_type_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeTypeListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_unassign_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeUnassignGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_unassign_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeUnassignSetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_value_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeValueAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_value_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeValueDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attribute_value_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttributeValueUpdateError {
    UnknownValue(serde_json::Value),
}


/// Add new attribute
pub async fn attribute_add(configuration: &configuration::Configuration, r#type: &str, name: &str, code: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, visible: Option<bool>, required: Option<bool>, position: Option<i32>, attribute_group_id: Option<&str>, is_global: Option<&str>, is_searchable: Option<bool>, is_filterable: Option<&str>, is_comparable: Option<bool>, is_html_allowed_on_front: Option<bool>, is_filterable_in_search: Option<bool>, is_configurable: Option<bool>, is_visible_in_advanced_search: Option<bool>, is_used_for_promo_rules: Option<bool>, used_in_product_listing: Option<bool>, used_for_sort_by: Option<bool>, apply_to: Option<&str>) -> Result<models::AttributeAdd200Response, Error<AttributeAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_name = name;
    let p_code = code;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_visible = visible;
    let p_required = required;
    let p_position = position;
    let p_attribute_group_id = attribute_group_id;
    let p_is_global = is_global;
    let p_is_searchable = is_searchable;
    let p_is_filterable = is_filterable;
    let p_is_comparable = is_comparable;
    let p_is_html_allowed_on_front = is_html_allowed_on_front;
    let p_is_filterable_in_search = is_filterable_in_search;
    let p_is_configurable = is_configurable;
    let p_is_visible_in_advanced_search = is_visible_in_advanced_search;
    let p_is_used_for_promo_rules = is_used_for_promo_rules;
    let p_used_in_product_listing = used_in_product_listing;
    let p_used_for_sort_by = used_for_sort_by;
    let p_apply_to = apply_to;

    let uri_str = format!("{}/attribute.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_code {
        req_builder = req_builder.query(&[("code", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_visible {
        req_builder = req_builder.query(&[("visible", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_required {
        req_builder = req_builder.query(&[("required", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_position {
        req_builder = req_builder.query(&[("position", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attribute_group_id {
        req_builder = req_builder.query(&[("attribute_group_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_global {
        req_builder = req_builder.query(&[("is_global", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_searchable {
        req_builder = req_builder.query(&[("is_searchable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_filterable {
        req_builder = req_builder.query(&[("is_filterable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_comparable {
        req_builder = req_builder.query(&[("is_comparable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_html_allowed_on_front {
        req_builder = req_builder.query(&[("is_html_allowed_on_front", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_filterable_in_search {
        req_builder = req_builder.query(&[("is_filterable_in_search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_configurable {
        req_builder = req_builder.query(&[("is_configurable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_visible_in_advanced_search {
        req_builder = req_builder.query(&[("is_visible_in_advanced_search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_used_for_promo_rules {
        req_builder = req_builder.query(&[("is_used_for_promo_rules", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_used_in_product_listing {
        req_builder = req_builder.query(&[("used_in_product_listing", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_used_for_sort_by {
        req_builder = req_builder.query(&[("used_for_sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_apply_to {
        req_builder = req_builder.query(&[("apply_to", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign attribute to the group
pub async fn attribute_assign_group(configuration: &configuration::Configuration, id: &str, group_id: &str, attribute_set_id: Option<&str>) -> Result<models::AttributeAssignGroup200Response, Error<AttributeAssignGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_group_id = group_id;
    let p_attribute_set_id = attribute_set_id;

    let uri_str = format!("{}/attribute.assign.group.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("group_id", &p_group_id.to_string())]);
    if let Some(ref param_value) = p_attribute_set_id {
        req_builder = req_builder.query(&[("attribute_set_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeAssignGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign attribute to the attribute set
pub async fn attribute_assign_set(configuration: &configuration::Configuration, id: &str, attribute_set_id: &str, group_id: Option<&str>) -> Result<models::AttributeAssignGroup200Response, Error<AttributeAssignSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attribute_set_id = attribute_set_id;
    let p_group_id = group_id;

    let uri_str = format!("{}/attribute.assign.set.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_group_id {
        req_builder = req_builder.query(&[("group_id", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("attribute_set_id", &p_attribute_set_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeAssignSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get attribute_set list
pub async fn attribute_attributeset_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, params: Option<&str>, exclude: Option<&str>, response_fields: Option<&str>) -> Result<models::ModelResponseAttributeAttributesetList, Error<AttributeAttributesetListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_params = params;
    let p_exclude = exclude;
    let p_response_fields = response_fields;

    let uri_str = format!("{}/attribute.attributeset.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeAttributesetListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get attributes count
pub async fn attribute_count(configuration: &configuration::Configuration, r#type: Option<&str>, attribute_set_id: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, visible: Option<bool>, required: Option<bool>, system: Option<bool>) -> Result<models::AttributeCount200Response, Error<AttributeCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_attribute_set_id = attribute_set_id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_visible = visible;
    let p_required = required;
    let p_system = system;

    let uri_str = format!("{}/attribute.count.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attribute_set_id {
        req_builder = req_builder.query(&[("attribute_set_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_visible {
        req_builder = req_builder.query(&[("visible", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_required {
        req_builder = req_builder.query(&[("required", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_system {
        req_builder = req_builder.query(&[("system", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete attribute from store
pub async fn attribute_delete(configuration: &configuration::Configuration, id: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<AttributeDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_store_id = store_id;

    let uri_str = format!("{}/attribute.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get attribute group list
pub async fn attribute_group_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, lang_id: Option<&str>, params: Option<&str>, exclude: Option<&str>, response_fields: Option<&str>, attribute_set_id: Option<&str>) -> Result<models::ModelResponseAttributeGroupList, Error<AttributeGroupListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_lang_id = lang_id;
    let p_params = params;
    let p_exclude = exclude;
    let p_response_fields = response_fields;
    let p_attribute_set_id = attribute_set_id;

    let uri_str = format!("{}/attribute.group.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attribute_set_id {
        req_builder = req_builder.query(&[("attribute_set_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeGroupListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information about a specific global attribute by its ID.
pub async fn attribute_info(configuration: &configuration::Configuration, id: &str, attribute_set_id: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, params: Option<&str>, exclude: Option<&str>, response_fields: Option<&str>) -> Result<models::AttributeInfo200Response, Error<AttributeInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attribute_set_id = attribute_set_id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_params = params;
    let p_exclude = exclude;
    let p_response_fields = response_fields;

    let uri_str = format!("{}/attribute.info.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_attribute_set_id {
        req_builder = req_builder.query(&[("attribute_set_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of global attributes.
pub async fn attribute_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, r#type: Option<&str>, attribute_ids: Option<&str>, attribute_set_id: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, params: Option<&str>, exclude: Option<&str>, response_fields: Option<&str>, visible: Option<bool>, required: Option<bool>, system: Option<bool>) -> Result<models::ModelResponseAttributeList, Error<AttributeListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_type = r#type;
    let p_attribute_ids = attribute_ids;
    let p_attribute_set_id = attribute_set_id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_params = params;
    let p_exclude = exclude;
    let p_response_fields = response_fields;
    let p_visible = visible;
    let p_required = required;
    let p_system = system;

    let uri_str = format!("{}/attribute.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attribute_ids {
        req_builder = req_builder.query(&[("attribute_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attribute_set_id {
        req_builder = req_builder.query(&[("attribute_set_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_visible {
        req_builder = req_builder.query(&[("visible", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_required {
        req_builder = req_builder.query(&[("required", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_system {
        req_builder = req_builder.query(&[("system", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of supported attributes types
pub async fn attribute_type_list(configuration: &configuration::Configuration, ) -> Result<models::AttributeTypeList200Response, Error<AttributeTypeListError>> {

    let uri_str = format!("{}/attribute.type.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeTypeListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unassign attribute from group
pub async fn attribute_unassign_group(configuration: &configuration::Configuration, id: &str, group_id: &str) -> Result<models::AttributeUnassignGroup200Response, Error<AttributeUnassignGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_group_id = group_id;

    let uri_str = format!("{}/attribute.unassign.group.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("group_id", &p_group_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeUnassignGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unassign attribute from attribute set
pub async fn attribute_unassign_set(configuration: &configuration::Configuration, id: &str, attribute_set_id: &str) -> Result<models::AttributeUnassignGroup200Response, Error<AttributeUnassignSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attribute_set_id = attribute_set_id;

    let uri_str = format!("{}/attribute.unassign.set.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("attribute_set_id", &p_attribute_set_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeUnassignSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update attribute data
pub async fn attribute_update(configuration: &configuration::Configuration, id: &str, name: &str, store_id: Option<&str>, lang_id: Option<&str>) -> Result<models::AttributeUpdate200Response, Error<AttributeUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_name = name;
    let p_store_id = store_id;
    let p_lang_id = lang_id;

    let uri_str = format!("{}/attribute.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add new value to attribute.
pub async fn attribute_value_add(configuration: &configuration::Configuration, attribute_id: &str, name: &str, code: Option<&str>, description: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>) -> Result<models::AttributeAdd200Response, Error<AttributeValueAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_attribute_id = attribute_id;
    let p_name = name;
    let p_code = code;
    let p_description = description;
    let p_store_id = store_id;
    let p_lang_id = lang_id;

    let uri_str = format!("{}/attribute.value.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("attribute_id", &p_attribute_id.to_string())]);
    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref param_value) = p_code {
        req_builder = req_builder.query(&[("code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeValueAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete attribute value.
pub async fn attribute_value_delete(configuration: &configuration::Configuration, id: &str, attribute_id: &str, store_id: Option<&str>) -> Result<models::AttributeValueDelete200Response, Error<AttributeValueDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attribute_id = attribute_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/attribute.value.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("attribute_id", &p_attribute_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeValueDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update attribute value.
pub async fn attribute_value_update(configuration: &configuration::Configuration, id: &str, attribute_id: &str, name: Option<&str>, description: Option<&str>, code: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>) -> Result<models::AttributeUpdate200Response, Error<AttributeValueUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attribute_id = attribute_id;
    let p_name = name;
    let p_description = description;
    let p_code = code;
    let p_store_id = store_id;
    let p_lang_id = lang_id;

    let uri_str = format!("{}/attribute.value.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("attribute_id", &p_attribute_id.to_string())]);
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_code {
        req_builder = req_builder.query(&[("code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<AttributeValueUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

