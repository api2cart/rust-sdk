/*
 * API2Cart OpenAPI
 *
 * API2Cart
 *
 * The version of the OpenAPI document: 1.1
 * Contact: contact@api2cart.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`category_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_add_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryAddBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_assign`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryAssignError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_find`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryFindError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_image_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryImageAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_image_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryImageDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_unassign`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryUnassignError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`category_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CategoryUpdateError {
    UnknownValue(serde_json::Value),
}


/// Add new category in store
pub async fn category_add(configuration: &configuration::Configuration, name: &str, description: Option<&str>, short_description: Option<&str>, parent_id: Option<&str>, avail: Option<bool>, created_time: Option<&str>, modified_time: Option<&str>, sort_order: Option<i32>, meta_title: Option<&str>, meta_description: Option<&str>, meta_keywords: Option<&str>, seo_url: Option<&str>, store_id: Option<&str>, stores_ids: Option<&str>, lang_id: Option<&str>) -> Result<models::CategoryAdd200Response, Error<CategoryAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_description = description;
    let p_short_description = short_description;
    let p_parent_id = parent_id;
    let p_avail = avail;
    let p_created_time = created_time;
    let p_modified_time = modified_time;
    let p_sort_order = sort_order;
    let p_meta_title = meta_title;
    let p_meta_description = meta_description;
    let p_meta_keywords = meta_keywords;
    let p_seo_url = seo_url;
    let p_store_id = store_id;
    let p_stores_ids = stores_ids;
    let p_lang_id = lang_id;

    let uri_str = format!("{}/category.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref param_value) = p_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_short_description {
        req_builder = req_builder.query(&[("short_description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_id {
        req_builder = req_builder.query(&[("parent_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail {
        req_builder = req_builder.query(&[("avail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_time {
        req_builder = req_builder.query(&[("created_time", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_time {
        req_builder = req_builder.query(&[("modified_time", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_meta_title {
        req_builder = req_builder.query(&[("meta_title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_meta_description {
        req_builder = req_builder.query(&[("meta_description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_meta_keywords {
        req_builder = req_builder.query(&[("meta_keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_seo_url {
        req_builder = req_builder.query(&[("seo_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stores_ids {
        req_builder = req_builder.query(&[("stores_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add new categories to the store.
pub async fn category_add_batch(configuration: &configuration::Configuration, category_add_batch: models::CategoryAddBatch) -> Result<models::CategoryAddBatch200Response, Error<CategoryAddBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_category_add_batch = category_add_batch;

    let uri_str = format!("{}/category.add.batch.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.json(&p_category_add_batch);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryAddBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign category to product
pub async fn category_assign(configuration: &configuration::Configuration, category_id: &str, product_id: &str, store_id: Option<&str>) -> Result<models::CategoryAssign200Response, Error<CategoryAssignError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_category_id = category_id;
    let p_product_id = product_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/category.assign.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("category_id", &p_category_id.to_string())]);
    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryAssignError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Count categories in store.
pub async fn category_count(configuration: &configuration::Configuration, parent_id: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, avail: Option<bool>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, product_type: Option<&str>, find_value: Option<&str>, find_where: Option<&str>, report_request_id: Option<&str>, disable_report_cache: Option<bool>) -> Result<models::CategoryCount200Response, Error<CategoryCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_parent_id = parent_id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_avail = avail;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_product_type = product_type;
    let p_find_value = find_value;
    let p_find_where = find_where;
    let p_report_request_id = report_request_id;
    let p_disable_report_cache = disable_report_cache;

    let uri_str = format!("{}/category.count.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_parent_id {
        req_builder = req_builder.query(&[("parent_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail {
        req_builder = req_builder.query(&[("avail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_type {
        req_builder = req_builder.query(&[("product_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_value {
        req_builder = req_builder.query(&[("find_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_report_request_id {
        req_builder = req_builder.query(&[("report_request_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_report_cache {
        req_builder = req_builder.query(&[("disable_report_cache", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete category in store
pub async fn category_delete(configuration: &configuration::Configuration, id: &str, store_id: Option<&str>) -> Result<models::CategoryDelete200Response, Error<CategoryDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_store_id = store_id;

    let uri_str = format!("{}/category.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search category in store. \"Laptop\" is specified here by default.
pub async fn category_find(configuration: &configuration::Configuration, find_value: &str, find_where: Option<&str>, find_params: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>) -> Result<models::CategoryFind200Response, Error<CategoryFindError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_find_value = find_value;
    let p_find_where = find_where;
    let p_find_params = find_params;
    let p_store_id = store_id;
    let p_lang_id = lang_id;

    let uri_str = format!("{}/category.find.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("find_value", &p_find_value.to_string())]);
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_params {
        req_builder = req_builder.query(&[("find_params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryFindError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add image to category
pub async fn category_image_add(configuration: &configuration::Configuration, category_id: &str, image_name: &str, url: &str, r#type: &str, store_id: Option<&str>, label: Option<&str>, mime: Option<&str>, position: Option<i32>) -> Result<models::CategoryImageAdd200Response, Error<CategoryImageAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_category_id = category_id;
    let p_image_name = image_name;
    let p_url = url;
    let p_type = r#type;
    let p_store_id = store_id;
    let p_label = label;
    let p_mime = mime;
    let p_position = position;

    let uri_str = format!("{}/category.image.add.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("category_id", &p_category_id.to_string())]);
    req_builder = req_builder.query(&[("image_name", &p_image_name.to_string())]);
    req_builder = req_builder.query(&[("url", &p_url.to_string())]);
    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_label {
        req_builder = req_builder.query(&[("label", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_mime {
        req_builder = req_builder.query(&[("mime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_position {
        req_builder = req_builder.query(&[("position", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryImageAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete image
pub async fn category_image_delete(configuration: &configuration::Configuration, category_id: &str, image_id: &str, store_id: Option<&str>) -> Result<models::AttributeDelete200Response, Error<CategoryImageDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_category_id = category_id;
    let p_image_id = image_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/category.image.delete.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("category_id", &p_category_id.to_string())]);
    req_builder = req_builder.query(&[("image_id", &p_image_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryImageDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get category info about category ID*** or specify other category ID.
pub async fn category_info(configuration: &configuration::Configuration, id: &str, store_id: Option<&str>, lang_id: Option<&str>, schema_type: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>, report_request_id: Option<&str>, disable_report_cache: Option<bool>) -> Result<models::CategoryInfo200Response, Error<CategoryInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_schema_type = schema_type;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;
    let p_report_request_id = report_request_id;
    let p_disable_report_cache = disable_report_cache;

    let uri_str = format!("{}/category.info.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_schema_type {
        req_builder = req_builder.query(&[("schema_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_report_request_id {
        req_builder = req_builder.query(&[("report_request_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_report_cache {
        req_builder = req_builder.query(&[("disable_report_cache", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of categories from store.
pub async fn category_list(configuration: &configuration::Configuration, start: Option<i32>, count: Option<i32>, page_cursor: Option<&str>, store_id: Option<&str>, lang_id: Option<&str>, parent_id: Option<&str>, avail: Option<bool>, product_type: Option<&str>, created_from: Option<&str>, created_to: Option<&str>, modified_from: Option<&str>, modified_to: Option<&str>, find_value: Option<&str>, find_where: Option<&str>, response_fields: Option<&str>, params: Option<&str>, exclude: Option<&str>, report_request_id: Option<&str>, disable_report_cache: Option<bool>, disable_cache: Option<bool>) -> Result<models::ModelResponseCategoryList, Error<CategoryListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start = start;
    let p_count = count;
    let p_page_cursor = page_cursor;
    let p_store_id = store_id;
    let p_lang_id = lang_id;
    let p_parent_id = parent_id;
    let p_avail = avail;
    let p_product_type = product_type;
    let p_created_from = created_from;
    let p_created_to = created_to;
    let p_modified_from = modified_from;
    let p_modified_to = modified_to;
    let p_find_value = find_value;
    let p_find_where = find_where;
    let p_response_fields = response_fields;
    let p_params = params;
    let p_exclude = exclude;
    let p_report_request_id = report_request_id;
    let p_disable_report_cache = disable_report_cache;
    let p_disable_cache = disable_cache;

    let uri_str = format!("{}/category.list.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_cursor {
        req_builder = req_builder.query(&[("page_cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_id {
        req_builder = req_builder.query(&[("parent_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail {
        req_builder = req_builder.query(&[("avail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product_type {
        req_builder = req_builder.query(&[("product_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_from {
        req_builder = req_builder.query(&[("created_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_to {
        req_builder = req_builder.query(&[("created_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_from {
        req_builder = req_builder.query(&[("modified_from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_to {
        req_builder = req_builder.query(&[("modified_to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_value {
        req_builder = req_builder.query(&[("find_value", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_find_where {
        req_builder = req_builder.query(&[("find_where", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_response_fields {
        req_builder = req_builder.query(&[("response_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_params {
        req_builder = req_builder.query(&[("params", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_report_request_id {
        req_builder = req_builder.query(&[("report_request_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_report_cache {
        req_builder = req_builder.query(&[("disable_report_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_disable_cache {
        req_builder = req_builder.query(&[("disable_cache", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unassign category to product
pub async fn category_unassign(configuration: &configuration::Configuration, category_id: &str, product_id: &str, store_id: Option<&str>) -> Result<models::CategoryAssign200Response, Error<CategoryUnassignError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_category_id = category_id;
    let p_product_id = product_id;
    let p_store_id = store_id;

    let uri_str = format!("{}/category.unassign.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("category_id", &p_category_id.to_string())]);
    req_builder = req_builder.query(&[("product_id", &p_product_id.to_string())]);
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryUnassignError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update category in store
pub async fn category_update(configuration: &configuration::Configuration, id: &str, name: Option<&str>, description: Option<&str>, short_description: Option<&str>, parent_id: Option<&str>, avail: Option<bool>, sort_order: Option<i32>, modified_time: Option<&str>, meta_title: Option<&str>, meta_description: Option<&str>, meta_keywords: Option<&str>, seo_url: Option<&str>, store_id: Option<&str>, stores_ids: Option<&str>, lang_id: Option<&str>) -> Result<models::AccountConfigUpdate200Response, Error<CategoryUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_name = name;
    let p_description = description;
    let p_short_description = short_description;
    let p_parent_id = parent_id;
    let p_avail = avail;
    let p_sort_order = sort_order;
    let p_modified_time = modified_time;
    let p_meta_title = meta_title;
    let p_meta_description = meta_description;
    let p_meta_keywords = meta_keywords;
    let p_seo_url = seo_url;
    let p_store_id = store_id;
    let p_stores_ids = stores_ids;
    let p_lang_id = lang_id;

    let uri_str = format!("{}/category.update.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_short_description {
        req_builder = req_builder.query(&[("short_description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_id {
        req_builder = req_builder.query(&[("parent_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_avail {
        req_builder = req_builder.query(&[("avail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sort_order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modified_time {
        req_builder = req_builder.query(&[("modified_time", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_meta_title {
        req_builder = req_builder.query(&[("meta_title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_meta_description {
        req_builder = req_builder.query(&[("meta_description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_meta_keywords {
        req_builder = req_builder.query(&[("meta_keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_seo_url {
        req_builder = req_builder.query(&[("seo_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_store_id {
        req_builder = req_builder.query(&[("store_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stores_ids {
        req_builder = req_builder.query(&[("stores_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang_id {
        req_builder = req_builder.query(&[("lang_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-store-key", value);
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CategoryUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

