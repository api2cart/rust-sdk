/*
 * API2Cart OpenAPI
 *
 * API2Cart
 *
 * The version of the OpenAPI document: 1.1
 * Contact: contact@api2cart.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct CartCouponAdd {
    /// Coupon code
    #[serde(rename = "code")]
    pub code: String,
    /// Coupon discount type
    #[serde(rename = "action_type")]
    pub action_type: ActionType,
    /// Defines where discount should be applied
    #[serde(rename = "action_apply_to")]
    pub action_apply_to: ActionApplyTo,
    /// Specify how discount should be applied. If scope=matching_items, then discount will be applied to each of the items that match action conditions. Scope order means that discount will be applied once.
    #[serde(rename = "action_scope")]
    pub action_scope: ActionScope,
    /// Defines the discount amount value.
    #[serde(rename = "action_amount")]
    pub action_amount: f64,
    /// Entity codes
    #[serde(rename = "codes", skip_serializing_if = "Option::is_none")]
    pub codes: Option<Vec<String>>,
    /// Coupon name
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Date start
    #[serde(rename = "date_start", skip_serializing_if = "Option::is_none")]
    pub date_start: Option<String>,
    /// Defines when discount code will be expired.
    #[serde(rename = "date_end", skip_serializing_if = "Option::is_none")]
    pub date_end: Option<String>,
    /// Usage limit for coupon.
    #[serde(rename = "usage_limit", skip_serializing_if = "Option::is_none")]
    pub usage_limit: Option<i32>,
    /// Usage limit per customer.
    #[serde(rename = "usage_limit_per_customer", skip_serializing_if = "Option::is_none")]
    pub usage_limit_per_customer: Option<i32>,
    /// Defines entity for action condition.
    #[serde(rename = "action_condition_entity", skip_serializing_if = "Option::is_none")]
    pub action_condition_entity: Option<String>,
    /// Defines entity attribute code for action condition.
    #[serde(rename = "action_condition_key", skip_serializing_if = "Option::is_none")]
    pub action_condition_key: Option<String>,
    /// Defines condition operator.
    #[serde(rename = "action_condition_operator", skip_serializing_if = "Option::is_none")]
    pub action_condition_operator: Option<String>,
    /// Defines condition attribute value/s. Can be comma separated string.
    #[serde(rename = "action_condition_value", skip_serializing_if = "Option::is_none")]
    pub action_condition_value: Option<String>,
    /// Indicates whether to apply a discount for taxes.
    #[serde(rename = "include_tax", skip_serializing_if = "Option::is_none")]
    pub include_tax: Option<bool>,
    /// Store Id
    #[serde(rename = "store_id", skip_serializing_if = "Option::is_none")]
    pub store_id: Option<String>,
    /// Defines whether the coupon provides free cash on delivery
    #[serde(rename = "free_cash_on_delivery", skip_serializing_if = "Option::is_none")]
    pub free_cash_on_delivery: Option<bool>,
    /// Retrieves orders specified by customer id
    #[serde(rename = "customer_id", skip_serializing_if = "Option::is_none")]
    pub customer_id: Option<String>,
    /// A unique identifier associated with a specific request. Repeated requests with the same <strong>idempotency_key</strong> return a cached response without re-executing the business logic. <strong>Please note that the cache lifetime is 15 minutes.</strong>
    #[serde(rename = "idempotency_key", skip_serializing_if = "Option::is_none")]
    pub idempotency_key: Option<String>,
}

impl CartCouponAdd {
    pub fn new(code: String, action_type: ActionType, action_apply_to: ActionApplyTo, action_scope: ActionScope, action_amount: f64) -> CartCouponAdd {
        CartCouponAdd {
            code,
            action_type,
            action_apply_to,
            action_scope,
            action_amount,
            codes: None,
            name: None,
            date_start: None,
            date_end: None,
            usage_limit: None,
            usage_limit_per_customer: None,
            action_condition_entity: None,
            action_condition_key: None,
            action_condition_operator: None,
            action_condition_value: None,
            include_tax: None,
            store_id: None,
            free_cash_on_delivery: None,
            customer_id: None,
            idempotency_key: None,
        }
    }
}
/// Coupon discount type
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ActionType {
    #[serde(rename = "percent")]
    Percent,
    #[serde(rename = "fixed")]
    Fixed,
}

impl Default for ActionType {
    fn default() -> ActionType {
        Self::Percent
    }
}
/// Defines where discount should be applied
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ActionApplyTo {
    #[serde(rename = "order_total")]
    OrderTotal,
    #[serde(rename = "item_price")]
    ItemPrice,
    #[serde(rename = "shipping")]
    Shipping,
}

impl Default for ActionApplyTo {
    fn default() -> ActionApplyTo {
        Self::OrderTotal
    }
}
/// Specify how discount should be applied. If scope=matching_items, then discount will be applied to each of the items that match action conditions. Scope order means that discount will be applied once.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ActionScope {
    #[serde(rename = "order")]
    Order,
    #[serde(rename = "matching_items")]
    MatchingItems,
}

impl Default for ActionScope {
    fn default() -> ActionScope {
        Self::Order
    }
}

